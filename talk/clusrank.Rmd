---
title: "Rank-Based Tests for Clustered Data with R package **clusrank**"
date: June 15, 2018
fontsize: 11pt
bibliography: clusrank.bib
output:
  beamer_presentation:
   theme: Madrid
   keep_tex: true
   toc: true
   slide_level: 2
   includes:
    in_header: in_header.tex
---



```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(dev = 'pdf')
knitr::opts_chunk$set(cache=TRUE)
options(width = 60)
```

# Introduction

## Background
* Two-group comparison: Wilcoxon rank sum test.
* Paired comparison: Wilcoxon signed rank test.
* Available implementations: \texttt{wilcox.test} in R package
  \textbf{stats}, \texttt{PROC NPAR1WAY} in SAS, \texttt{ranksum/signrank}
  in Stata, StatXact and etc.
* Not suitable for non-iid data.

## Rank-Based Tests for CLustered Data
* Clustered data: not iid.
* Rank-sum tests for clustered data: @Rosn:Glyn:Lee:inco:2003,
  @Rosn:Glyn:Lee:exte:2006, @Datt:Satt:rank:2005, and @Dutt:Datt:rank:2016.
* Signed-rank tests for clustered data: @Rosn:Grov:use:1999,
  @Rosn:Glyn:Lee:inco:2003 and @Datt:Satt:rank:2005.
* Some existing software for clustered data
    + R package \texttt{coin}: conditional inferences.
    + R package \texttt{ClusterRankTest}: @Dutt:Datt:clus:2016.
    + Stata function \texttt{cluswilcox}: RGL.
	+ Available SAS code for RGL methods.

## R Package **clusrank**
- Provides a unified interface for the above mentioned rank-based tests for clustered data.
<!-- - Modeled after the base function \texttt{wilcox.test} -->
- Available on \texttt{CRAN}.
```{r, echo = TRUE}
library(clusrank)
```
```{r, echo = FALSE}
args(clusrank:::clusWilcox.test.formula)
```

# Clustered Rank-Sum Tests
## RGL Method with Cluster-Level Grouping
- RGL method:  @Rosn:Glyn:Lee:inco:2003
- Treatment is assigned at the cluster level.
- Compares groups at each cluster size.
- Assuming exchangeable intracluster dependence structure.
- Large-sample test.
- Exact permutation test for small sample is available.
- Imbalance of sample sizes between two groups across cluster size strata
  may result in inefficiency.

## Illustration: data
```{r, echo = FALSE}
library(mvtnorm)

ex  <- function(dim, rho) {
  diag(1 - rho, dim) + matrix(rho, dim, dim)
}

ar1 <- function(dim, rho) {
  rho ^ outer(1:dim, 1:dim, function(x, y) abs(x - y))
}

datgen.sum <- function(nclus, maxclsize, delta = 0.,
  rho = c(0.1, 0.1), corr = ex, misrate = 0., clusgrp = TRUE) {
    nn <- nclus * maxclsize
    Sigma1 <- corr(maxclsize, rho[1])
    Sigma2 <- corr(maxclsize, rho[2])
    y1 <- c(t(rmvnorm(nclus, sigma = Sigma1)))
    y2 <- c(t(rmvnorm(nclus, sigma = Sigma2)))
    group <- rep(c(0, 1), each = nn)
    if (!clusgrp) group  <- sample(group, nn, FALSE)
    cid <- rep(1:(2 * nclus), each = maxclsize)
    x <- exp(c(y1, y2)) + delta * group
    dat <- data.frame(x = x, grp = group, cid = cid)
    drop <-  sort(sample(1:(2 * nn), size = misrate * (2 * nn), FALSE))
    if (misrate == 0.) dat else dat[-drop, ]
}

dat.cls <- datgen.sum(10, 3, 0, c(.9, .9), ex, 0, TRUE)
```
Data \texttt{dat.cls} contains $10$ clusters from each of the two groups,
and the grouping is assigned at the cluster level.
```{r dat-clusd, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE}
dat.cls <- datgen.sum(10, 3, 0, c(.9, .9), ex, 0, TRUE)
head(dat.cls)
```
## Illustration
```{r dat-clus0, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE}
clusWilcox.test(x ~ grp + cluster(cid),
                data = dat.cls, method = "rgl", exact = TRUE, B = 0)
```

## Illustration
```{r dat-clus1, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE}
clusWilcox.test(x ~ grp + cluster(cid),
                data = dat.cls, method = "rgl")
```

## Illustration
RGL method with cluster-level grouping also allows an extra \texttt{stratum}
variable:
```{r dat-clusstr, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE}
dat.cls$strat <- rep(rep(1:2, each = 15), 2)
## cbind(head(dat.cl, 6), "head / tail" = "     ", tail(dat.cl, 6))
clusWilcox.test(x ~ grp + cluster(cid) + stratum(strat), dat = dat.cls,
  method = "rgl")
```


## DS Method with Individual-Level Grouping
- DS method: @Datt:Satt:rank:2005
- Treatment is assigned at individual level.
- Within-cluster resampling.
- Able to compare location among $m >= 2$ treatment groups. (chi-square
  distribution.)
- Cannot be applied to strictly collateral data.

## Illustration
```{r dat-clus2, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE}
clusWilcox.test(x ~ grp + cluster(cid),
                data = dat.cls, method = "ds")
```

## Illustration
Data \texttt{dat.cl1} is the same as \texttt{dat.cls} except it contains $4$
groups.

```{r dat-clus3, echo = FALSE, fig.width = 2, fig.height = 2, warning = FALSE}
dat.cl1 <- dat.cls
dat.cl1$grp <- rep(1:4, each = 15)
```
```{r dat-clus4, echo = FALSE, fig.width = 2, fig.height = 2, warning = FALSE}
clusWilcox.test(x ~ grp + cluster(cid), dat = dat.cl1, method = "ds")
```


## DD method: Number of Subjects in a Group within a Cluster is Informative
- DD method: @Dutt:Datt:rank:2016
- Group specific marginal distribution in a cluster depends on the number of
  observations in that group.
- Two-stage resampling.
```{r dat-clus5, echo = FALSE, fig.width = 2, fig.height = 2, warning = FALSE}
clusWilcox.test(x ~ grp + cluster(cid), dat = dat.cls, method = "dd")
```



## RGL Method with Individual-Level Grouping
- RGL method: @Rosn:Glyn:Lee:exte:2006
- Treatment is assigned at individual level.
- Is equivalent to RGL method with cluster-level grouping when the data is
  balanced and the treatment is also assigned at cluster-level.





## More Remarks
- DS method allows arbitrary intra-cluster dependence structure and remains valid when treatment affects the correlation structure.
- RGL method is more efficient than DS method when the intra-cluster correlation is weak.
- Permutation test is only available for RGL method when treatments are
  assigned at cluster level. The permutation test can be applied to small
  sample (number of clusters less than $20$).

# Clustered Signed-Rank Tests
## RGL Method: Uninformative Cluster Size.
- @Rosn:Glyn:Lee:inco:2003.
- Informative cluster size: the distribution of pairwise differences within a cluster depends on the cluster size.
- The RGL test does not hold the size when the cluster size is informative.
- Permutation test for the RGL method is supported only for small sample
  (less than $50$).

## Illustration: Data
Data \texttt{dat1} contains the paired difference from $10$ clusters, each
cluster has $5$ subunits. The difference in location is $1$.
```{r, echo = FALSE}
datgen.sgn <- function(nclus, maxclsize, delta = 0.,
  rho = 0.1, corr = ex, misrate = 0.) {
    nn <- nclus * maxclsize
    Sigma <- corr(maxclsize, rho)
    z <- delta + c(t(rmvnorm(nclus, sigma = Sigma)))
    x <- sign(z) * exp(abs(z))
    cid <- rep(1:nclus, each = maxclsize)
    dat <- data.frame(x = x, cid = cid)
    drop <- sort(sample(1:nn, size = misrate * nn, FALSE))
    if (misrate == 0.) dat else dat[-drop,]
}
dat1 <- datgen.sgn(10, 5, rho = 0.9, delta = 1)
```
```{r, echo = TRUE}
head(dat1)
```
## Illustration:
```{r, echo = TRUE, warning = FALSE}
## Default method is RGL.
clusWilcox.test(x ~ cluster(cid), data = dat1,
                paired = TRUE)

```

##   DS method: informative cluster size
* Allows informative cluster size.
* Rationale:
    + randomly draw an individual from each cluster to form a pseudo-sample.
    + average the signed rank statistic of all possible pseudo-samples.

## Illustration
```{r, echo = TRUE}
clusWilcox.test(x ~ cluster(cid), data = dat1,
                paired = TRUE, method = "ds")
```




<!-- # Illustration -->

<!-- ## Illustration -->

<!-- ```{r, echo = TRUE} -->
<!-- library(clusrank) -->
<!-- ``` -->
<!-- The synopsis of the formula interface of the function is -->
<!-- ```{r, echo = FALSE} -->
<!-- args(clusrank:::clusWilcox.test.formula) -->
<!-- ``` -->
<!-- The model formula can have \texttt{cluster()}. -->

<!-- ## Illustration: Two Within-Cluster Correlation Structures -->
<!-- ```{r, echo = TRUE, tidy = TRUE, size = 'smallsize'} -->
<!-- library(mvtnorm) -->

<!-- ex  <- function(dim, rho) { -->
<!--   diag(1 - rho, dim) + matrix(rho, dim, dim) -->
<!-- } -->

<!-- ar1 <- function(dim, rho) { -->
<!--   rho ^ outer(1:dim, 1:dim, function(x, y) abs(x - y)) -->
<!-- } -->
<!-- ``` -->

<!-- ## Illustration: Generate Data for Clustered Rank-Sum Test -->
<!-- ```{r, echo = TRUE, tidy = TRUE, size = 'smallsize'} -->
<!-- datgen.sum <- function(nclus, maxclsize, delta = 0., -->
<!--   rho = c(0.1, 0.1), corr = ex, misrate = 0., clusgrp = TRUE) { -->
<!--     nn <- nclus * maxclsize -->
<!--     Sigma1 <- corr(maxclsize, rho[1]) -->
<!--     Sigma2 <- corr(maxclsize, rho[2]) -->
<!--     y1 <- c(t(rmvnorm(nclus, sigma = Sigma1))) -->
<!--     y2 <- c(t(rmvnorm(nclus, sigma = Sigma2))) -->
<!--     group <- rep(c(0, 1), each = nn) -->
<!--     if (!clusgrp) group  <- sample(group, nn, FALSE) -->
<!--     cid <- rep(1:(2 * nclus), each = maxclsize) -->
<!--     x <- exp(c(y1, y2)) + delta * group -->
<!--     dat <- data.frame(x = x, grp = group, cid = cid) -->
<!--     drop <-  sort(sample(1:(2 * nn), size = misrate * (2 * nn), FALSE)) -->
<!--     if (misrate == 0.) dat else dat[-drop, ] -->
<!-- } -->
<!-- ``` -->

<!-- ## Illustration: Clustered Rank Sum Test -->
<!-- - The \texttt{datgen.sum} function generates clustered data with treatment assigned either to cluster or to individual. -->

<!-- - Arguments: -->
<!--     + \texttt{nclus}: the number of clusters -->
<!--     + \texttt{maxclsize}: the maximum of cluster size -->
<!--     + \texttt{delta}: the difference in the location of the two treatment groups -->
<!--     + \texttt{rho}: intra-cluster correlation of each treatment group -->
<!--     + \texttt{rate}: a parameter controls the unbalancedness of the data randomly -->
<!--     + \texttt{grpleve}: switch of the level on which treatment is assigned -->


<!-- ## Illustration: Clustered Rank Sum Test -->
<!-- The first data set has $10$ clusters in each of the two groups, and the grouping is at the cluster level. -->
<!-- ```{r dat-clus0, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE} -->
<!-- dat.cls <- datgen.sum(10, 3, 0, c(.9, .9), ex, 0, TRUE) -->
<!-- head(dat.cls) -->
<!-- ``` -->
<!-- ## Illustration: Clustered Rank Sum Test -->
<!-- ```{r dat-clus1, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE} -->
<!-- clusWilcox.test(x ~ grp + cluster(cid), -->
<!--                 data = dat.cls, method = "rgl") -->
<!-- ``` -->

<!-- ## Illustration: Clustered Rank Sum Test -->

<!-- ```{r dat-clus2, echo = TRUE, fig.width = 2, fig.height = 2, warning = FALSE} -->
<!-- clusWilcox.test(x ~ grp + cluster(cid), -->
<!--                 data = dat.cls, method = "ds") -->
<!-- ``` -->


<!-- ## Illustration: Clustered Rank Sum Test -->
<!-- The next data set has individual level grouping. -->
<!-- ```{r dat-indi0, echo = TRUE, warning = FALSE} -->
<!-- dat.ind <- datgen.sum(10, 3, 0, c(.9, .9), ex, 0, FALSE) -->
<!-- head(dat1.ind) -->
<!-- ``` -->

<!-- ## Illustration: Clustered Rank Sum Test -->
<!-- ```{r dat-indi1, echo = TRUE, warning = FALSE} -->
<!-- clusWilcox.test(x ~ grp + cluster(cid), -->
<!--                 data = dat.ind, method = "rgl") -->
<!-- ``` -->

<!-- ## Illustration: Clustered Rank Sum Test -->
<!-- ```{r dat-indi2, echo = TRUE, warning = FALSE} -->
<!-- clusWilcox.test(x ~ grp + cluster(cid), -->
<!--                 data = dat.ind, method = "ds") -->
<!-- ``` -->


<!-- ## Illustration: Clustered Signed Rank Test -->
<!--  Data generating function: -->
<!-- ```{r, echo = TRUE} -->
<!-- datgen.sgn <- function(nclus, maxclsize, delta = 0., -->
<!--   rho = 0.1, corr = ex, misrate = 0.) { -->
<!--     nn <- nclus * maxclsize -->
<!--     Sigma <- corr(maxclsize, rho) -->
<!--     z <- delta + c(t(rmvnorm(nclus, sigma = Sigma))) -->
<!--     x <- sign(z) * exp(abs(z)) -->
<!--     cid <- rep(1:nclus, each = maxclsize) -->
<!--     dat <- data.frame(x = x, cid = cid) -->
<!--     drop <- sort(sample(1:nn, size = misrate * nn, FALSE)) -->
<!--     if (misrate == 0.) dat else dat[-drop,] -->
<!-- } -->
<!-- ``` -->

<!-- ## Illustration: Clustered Signed Rank Test -->
<!-- - The function \texttt{datgen.sgn} generate clustered difference between observations before and after treatment. -->
<!-- - Arguments: -->
<!--     * nclus, maxclsize, delta, rate: Same as the those of \texttt{datgen.sum}. -->
<!--     *  rho: intracluster correlation, assuming treatment does not change the intracluster correlation. -->




<!-- ## Illustration: Clustered Signed Rank Test -->
<!-- ```{r dat-clus-0s, echo = TRUE} -->
<!-- dat1 <- datgen.sgn(10, 5, rho = 0.9, delta = 1) -->
<!-- head(dat1) -->
<!-- ``` -->


<!-- ## Illustration: Clustered Signed Rank Test -->
<!-- ```{r, echo = TRUE} -->
<!-- ## Default method is RGL. -->
<!-- clusWilcox.test(x ~ cluster(cid), data = dat1, -->
<!--                 paired = TRUE) -->

<!-- ``` -->

<!-- ## Illustration: Clustered Signed Rank Test -->
<!-- ```{r, echo = TRUE} -->
<!-- clusWilcox.test(x ~ cluster(cid), data = dat1, -->
<!--                 paired = TRUE, method = "ds") -->
```

## Data Generation
```{r, echo = TRUE, tidy = TRUE, size = 'smallsize'}
ex  <- function(dim, rho) {
  diag(1 - rho, dim) + matrix(rho, dim, dim)
}

ar1 <- function(dim, rho) {
  rho ^ outer(1:dim, 1:dim, function(x, y) abs(x - y))
}

datgen.sum <- function(nclus, maxclsize, delta = 0.,
  rho = c(0.1, 0.1), corr = ex, misrate = 0., clusgrp = TRUE) {
    nn <- nclus * maxclsize
    Sigma1 <- corr(maxclsize, rho[1])
    Sigma2 <- corr(maxclsize, rho[2])
    y1 <- c(t(rmvnorm(nclus, sigma = Sigma1)))
    y2 <- c(t(rmvnorm(nclus, sigma = Sigma2)))
    group <- rep(c(0, 1), each = nn)
    if (!clusgrp) group  <- sample(group, nn, FALSE)
    cid <- rep(1:(2 * nclus), each = maxclsize)
    x <- exp(c(y1, y2)) + delta * group
    dat <- data.frame(x = x, grp = group, cid = cid)
    drop <-  sort(sample(1:(2 * nn), size = misrate * (2 * nn), FALSE))
    if (misrate == 0.) dat else dat[-drop, ]
}
```


## Simulation Comparison Made Easy
```{r, echo = TRUE}
simpower <- function(nrep, level, paired, nclus, maxclsize,
  delta, rho, corr, misrate, ...) {
    do1rep <- function() {
      datgen <- if (paired) datgen.sgn else datgen.sum
      formula <- if (paired) x ~ cluster(cid)
                 else x ~ cluster(cid) + grp
      dat <- datgen(nclus, maxclsize, delta, rho, corr, misrate, ...)
      p.rgl <- clusWilcox.test(formula, paired = paired,
                               data = dat, method = "rgl")$p.value
      p.ds  <- clusWilcox.test(formula, paired = paired,
                               data = dat, method = "ds" )$p.value
      c(rgl = p.rgl, ds = p.ds)
    }
    sim <- t(replicate(nrep, do1rep()))
    apply(sim, 2, function(x) mean(x < level))
}
```

## Simulation comparison
```{r, echo = TRUE}
## Rank-sum tests
simpower(1000, 0.05, FALSE, 20, 3, 0.0, c(0.5, 0.5), ex,  0.,
         clusgrp = TRUE)
## Signed-rank tests
simpower(1000, 0.05, TRUE,  20, 3, 0.0, 0.5, ar1, 0.)
```


# Conclusions
## Conclusion
- \texttt{clusWilcox.test} from package \textbf{clusrank} is a unified interface of clustered rank sum test and clustered signed rank test.
- For clustered rank-sum test: RGL, DS and DD. For clustered signed-rank
  test: RGL and DS.
- Future work: clustered sign test, sample size determination, rank
  regression...
- Questions to maintainer: Yujing Jiang
- Thank you!

## References
